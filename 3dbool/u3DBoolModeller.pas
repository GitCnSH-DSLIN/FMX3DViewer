unit u3DBoolModeller;

interface

uses
  System.SysUtils, System.Types, System.UITypes, System.Classes, System.Variants,
  System.Math, System.Generics.Collections, System.Math.Vectors,
  FMX.Types, FMX.Graphics, FMX.Types3D, FMX.Objects3D, FMX.Controls3D,
  u3DBoolMisc, u3DBoolBound, u3DBoolVertex, u3DBoolFace,
  u3DBoolSegment, u3DBoolSolid, u3DBoolObject3D
  ;

type
  T3DBoolModeller = class
  private
    m_oObject1: T3DBoolObject3D;
    m_oObject2: T3DBoolObject3D;
    function composeSolid(i_iFaceStatus1, i_iFaceStatus2, i_iFaceStatus3: enVertexFaceType): T3DBoolSolid;
    procedure groupObjectComponents(anObject : T3DBoolObject3D;
                                    i_iFaceStatus1, i_iFaceStatus2: enVertexFaceType;
                                    var o_lstVertices: TList<T3DBoolVertex>;
                                    var o_lstIndices : TList<Cardinal>;
                                    var o_lstColors  :  TList<TColor> );
  public
    constructor Create(); overload;
    constructor Create(solid1, solid2: T3DBoolSolid); overload;
    destructor Destroy; override;
    //
    function clone(): T3DBoolModeller;
    function getUnion(): T3DBoolSolid;
    function getIntersection(): T3DBoolSolid;
    function getDifference():   T3DBoolSolid;
  end;


implementation

{ T3DBoolModeller }

constructor T3DBoolModeller.Create();
begin
 inherited Create;
end;

destructor T3DBoolModeller.Destroy();
begin
 inherited Destroy;
end;

constructor T3DBoolModeller.Create(solid1, solid2: T3DBoolSolid);
begin
 //representation to apply boolean operations
 m_oObject1 := T3DBoolObject3D.Create(solid1);
 m_oObject2 := T3DBoolObject3D.Create(solid2);
 //split the faces so that none of them intercepts each other
 m_oObject1.splitFaces(m_oObject2);
 m_oObject2.splitFaces(m_oObject1);
 // classify faces as being inside or outside the other solid
 m_oObject1.classifyFaces(m_oObject2);
 m_oObject2.classifyFaces(m_oObject1);
end;

// Clones the BooleanModeller object
//   @return cloned BooleanModeller object
function T3DBoolModeller.clone(): T3DBoolModeller;
var
 clone : T3DBoolModeller;
begin
 clone := T3DBoolModeller.Create;
 clone.m_oObject1 := m_oObject1.Clone();
 clone.m_oObject2 := m_oObject2.Clone();
 Result := clone;
end;

// Gets the solid generated by the union of the two solids submitted to the constructor
//   @return solid generated by the union of the two solids submitted to the constructor
function T3DBoolModeller.getUnion(): T3DBoolSolid;
begin
 Result := composeSolid(enVertexFaceType.OUTSIDE,enVertexFaceType.SAME,enVertexFaceType.OUTSIDE);
end;

// Gets the solid generated by the intersection of the two solids submitted to the constructor
//   @return solid generated by the intersection of the two solids submitted to the constructor.
//           The generated solid may be empty depending on the solids. In this case, it can't be used on a scene
//           graph. To check this, use the Solid.isEmpty() method.
function T3DBoolModeller.getIntersection(): T3DBoolSolid;
begin
 Result := composeSolid(enVertexFaceType.INSIDE,enVertexFaceType.SAME,enVertexFaceType.INSIDE);
end;

// Gets the solid generated by the intersection of the two solids submitted to the constructor
//   @return solid generated by the intersection of the two solids submitted to the constructor.
//          The generated solid may be empty depending on the solids. In this case, it can't be used on a scene
//          graph. To check this, use the Solid.isEmpty() method.
function T3DBoolModeller.getDifference(): T3DBoolSolid;
var
 res : T3DBoolSolid;
begin
 m_oObject2.invertInsideFaces();
 res := self.composeSolid(enVertexFaceType.OUTSIDE,enVertexFaceType.OPPOSITE,enVertexFaceType.INSIDE);
 m_oObject2.invertInsideFaces();
 result := res;
end;

// Composes a solid based on the faces status of the two operators solids:
// Face.INSIDE, Face.OUTSIDE, Face.SAME, Face.OPPOSITE
//   @param faceStatus1 status expected for the first solid faces
//   @param faceStatus2 other status expected for the first solid faces
//         (expected a status for the faces coincident with second solid faces)
//   @param faceStatus3 status expected for the second solid faces
function T3DBoolModeller.composeSolid(i_iFaceStatus1, i_iFaceStatus2, i_iFaceStatus3: enVertexFaceType): T3DBoolSolid;
var
 i : Integer;
 l_lstVertices: TList<T3DBoolVertex>;
 l_lstIndices : TList<Cardinal>;
 l_lstColors  : TList<TColor>;
 l_lstVerticesArray: TList<T3DBoolPoint3d>;
 l_lstIndicesArray:  TList<Cardinal>;
 l_lstColorsArray :  TList<TColor>;
begin
 l_lstVertices := TList<T3DBoolVertex>.Create;
 l_lstIndices  := TList<Cardinal>.Create;
 l_lstColors   := TList<TColor>.Create;
 // group the elements of the two solids whose faces fit with the desired status
 self.groupObjectComponents(m_oObject1,i_iFaceStatus1,i_iFaceStatus2,l_lstVertices,l_lstIndices,l_lstColors);
 self.groupObjectComponents(m_oObject2,i_iFaceStatus3,i_iFaceStatus3,l_lstVertices,l_lstIndices,l_lstColors);
 // turn the arrayLists to arrays
 l_lstVerticesArray := TList<T3DBoolPoint3d>.Create;
 for i := 0 to l_lstVertices.Count-1 do
   l_lstVerticesArray.Add(l_lstVertices[i].getPosition());
 l_lstIndicesArray := TList<Cardinal>.Create;
 for i := 0 to l_lstIndices.Count-1 do
   l_lstIndicesArray.Add(l_lstIndices[i]);
 l_lstColorsArray := TList<TColor>.Create;
 for i := 0 to l_lstColors.Count-1 do
   l_lstColorsArray.Add(l_lstColors[i]);
 // returns the solid containing the grouped elements
 Result := T3DBoolSolid.Create(l_lstVerticesArray,l_lstIndicesArray,l_lstColorsArray);
end;

// Fills solid arrays with data about faces of an object generated whose status
// is as required
//   @param object3d solid object used to fill the arrays
//   @param vertices vertices array to be filled
//   @param indices indices array to be filled
//   @param colors colors array to be filled
//   @param faceStatus1 a status expected for the faces used to to fill the data arrays
//   @param faceStatus2 a status expected for the faces used to to fill the data arrays
procedure T3DBoolModeller.groupObjectComponents(anObject : T3DBoolObject3D;
                                    i_iFaceStatus1, i_iFaceStatus2: enVertexFaceType;
                                    var o_lstVertices: TList<T3DBoolVertex>;
                                    var o_lstIndices : TList<Cardinal>;
                                    var o_lstColors  : TList<TColor> );
var
 i, j, l_iNumFaces : integer;
 face : T3DBoolFace;
 faceVerts : array[0..2] of T3DBoolVertex;
begin
 // for each face..
 l_iNumFaces := anObject.getNumFaces();
 for i := 0 to l_iNumFaces-1 do begin
   face := anObject.getFace(i);
   // if the face status fits with the desired status...
   if (face.getStatus() = i_iFaceStatus1) or (face.getStatus() = i_iFaceStatus2) then begin
	   // adds the face elements into the arrays
     faceVerts[0] := face.v1;
     faceVerts[1] := face.v2;
     faceVerts[2] := face.v3;
     for j := Low(faceVerts) to High(faceVerts) do begin
       if (o_lstVertices.contains(faceVerts[j])) then begin
         o_lstIndices.add(o_lstVertices.IndexOf(faceVerts[j]));
       end
       else begin
         o_lstIndices.add(o_lstVertices.Count);
         o_lstVertices.add(faceVerts[j]);
         o_lstColors.add(faceVerts[j].getColor());
       end;
     end;
   end;
 end;
end;

end.
